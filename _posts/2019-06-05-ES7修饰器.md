---
title: ES7的修饰器
description: ES7的修饰器
categories:
 - technology
tags:
---

>准备写这篇博客，是因为年初在找工作的时候，面试被问到了修饰器，对于ES6的好多新特性和方法还一知半解的我来说太超纲了！因此决定好好研究一下这是个啥[捂脸]～

### 1、使用

#### 1）安装decorators插件：

```javascript
    npm install babel-plugin-transform-decorators-legacy --save-dev 
```

在.babelrc中添加以下配置：

```javascript
    "plugins": ["transform-decorators-legacy"],
```

#### 2）示例：

```javascript
@testable
class MyTestableClass {
    // ...
}

function testable(target) {
    //这里的target是MyTestableClass类
    target.isTestable = true;
}

console.log(MyTestableClass.isTestable); // true
```

上面代码中，@testable就是一个修饰器，它修改了MyTestableClass这个类的行为，为其添加了属性isTestable。

上述只是个简单的例子，修饰器一般接受三个参数：

- 需要定义属性的对象（MyTestableClass）

- 需要定义或修改的属性的名字

- 将被定义或修改的属性的描述符（属性的描述对象）

```javascript
function readonly(target, name, descriptor){
     //...
 }
```

descriptor和Object.defineProperty() 一样: {value: [Function], writable: true, enumerable: false, configurable: true}

#### 3）特性：

- 由多个修饰器时，先从外到内进入，再由内向外执行。

```javascript
function dec(id){
    console.log('evaluated', id);
    return (target, property, descriptor) => console.log('executed', id);
}

class Example {
    @dec(1)
    @dec(2)
    method(){}
}
//evaluated 1
//evaluated 2
//executed 2
//executed 1
```

上述代码中，dec修饰器又返回了一个修饰器，根据其特性，外层修饰器@dec(1)先进入，但是内层修饰器@dec(2)先执行。

- 修饰器不能用于普通函数，因为普通函数存在变量提升。

### 2、修饰器集合

core-decorators.js中内置了很多修饰器，可以根据实际情况使用。

```javascript
import { autobind } from 'core-decorators';

class Person {
    @autobind
    getPerson() {
        return this;
    }
}

let person = new Person();
let getPerson = person.getPerson;

getPerson() === person;
// true
```

以上是一个绑定原始对象的修饰器，还有：

- readonly：使属性或方法不可写；
- override：检查子类是否覆盖父类的同名方法；
- deprecate：在控制台显示一条警告，表示该方法将废除；
- suppressWarnings：抑制deprecated修饰器导致的console.warn()调用。但是，异步代码发出的调用除外；
- ......

参考文档：
[ES6入门-修饰器](http://es6.ruanyifeng.com/#docs/decorator)

[探寻 ECMAScript 中的装饰器 Decorator](https://github.com/rccoder/blog/issues/23)
