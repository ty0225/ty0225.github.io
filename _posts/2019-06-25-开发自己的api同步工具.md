---
title: 开发api同步工具
description: 开发api同步工具
categories:
 - technology
tags:
---

> 我们在项目开发的过程中，想要提升开发效率，要从各个方面入手，比如同步api接口。

目前服务端有很多比较流行的接口文档管理工具，比如swagger。本次api同步工具，以swagger为文档管理为基础。

首先以[vswagger-cli](https://github.com/Git-leng/vswagger-cli)为例，看下这个工具的代码结构。

### 一、分析依赖包的功能

#### 1、axios：是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。

#### 2、chalk：是一个颜色的插件。

#### 3、commander：是一个轻巧的nodejs模块，提供了用户命令行输入和参数解析强大功能。commander源自一个同名的Ruby项目。

可进行对外命令扩展 即用其配置node命令

- option(): 初始化自定义参数对象，设置“关键字”和“描述”。通过option设置的选项可以通过program.chdir或者program.noTests来访问。
- command(): 初始化命令行参数对象，直接获得命令行输入。通过command设置的命令通常在action回调中处理逻辑。
- Command.command(): 定义一个命令名字
- Command.action(): 注册一个callback函数
- Command.option(): 定义参数，需要设置“关键字”和“描述”，关键字包括“简写”和“全写”两部分，以”,”,”|”,”空格”做分隔。
- Command.parse(): 解析命令行参数argv
- Command.description(): 设置description值
- Command.usage(): 设置usage值

#### 4、download-git-repo： 下载并解压缩git存储库。

#### 5、lodash： 是一个一致性、模块化、高性能的 JavaScript 实用工具库。

lodash的几个优点：
- lodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。
- lodash 的模块化方法 非常适用于：

- 遍历 array、object 和 string
- 对值进行操作和检测
- 创建符合功能的函数

#### 6、metalsmith： 一个非常简单，可插拔的静态网站生成器，

#### 7、ora： 主要用来实现node.js命令行环境的loading效果，和显示各种状态的图标等

#### 8、rimraf ：以包的形式包装rm -rf命令，就是用来删除文件和文件夹的，不管文件夹是否为空，都可以删除。

#### 9、semver：它是 语义化版本（Semantic Versioning）规范 的一个实现，目前是由 npm 的团队维护的，实现了版本和版本范围的解析、计算、比较，在 NPM 的被依赖（Most depended-upon）榜单中排名 34.

#### 10、tildify：把绝对路径转化成波浪路径， 如 /Users/sindresorhus/dev → ~/dev

#### 11、user-home：获取用户主目录的路径

### 二、源码解析

#### 1、vswagger

```javascript
#!/usr/bin/env node
require('commander')
    .version(require('../package').version)
    .usage('<command> [options]')
    .command('init', 'generate a new API from a template')
    .command('clean', 'clean it!')
    .command('check', 'check code!')
    .parse(process.argv)
```
这里是扩展一些外部命令：vswagger init，vswagger clean，vswagger check，供项目开发者使用。

#### 2、vswagger-init

```javascript
    #!/usr/bin/env node
    var _ = require('lodash');
    var fs = require('fs');
    var path = require('path');
    var program = require('commander');
    var chalk = require('chalk');
    var ora = require('ora');
    var home = require('user-home');
    var rimraf = require('rimraf');
    var tildify = require('tildify');
    var download = require('download-git-repo');
    var logger = require('../lib/logger');
    var generate = require('../lib/generate');
    var localPath = require('../lib/local-path');
    var checkVersion = require('../lib/check-version');
    
    var isLocalPath = localPath.isLocalPath;
    var getTemplatePath = localPath.getTemplatePath;
    
    
    program
      .usage('[project-path]')//定义usage值
      .usage('[project-name]')
      .option('-c, --clone', '使用 git clone')//给vswagger init命令添加参数
      .option('--offline', '使用缓存模板')
      .parse(process.argv);
    
    run();
    var projectPath;
    
    function run() {
        var fileName = '.vswagger.js';
        //process.cwd() 方法返回 Node.js 进程的当前工作目录
        projectPath = program.args[0] ? path.resolve(process.cwd(), program.args[0]) : process.cwd();
        var configPath = path.join(projectPath, fileName);
        //判断.vswagger.js文件是否存在
        if (!fs.existsSync(configPath)) {
            logger.fatal('找不到 '+ fileName +' 配置文件');
        }
    
        var config = require(configPath);
        var projectName = program.args[1];
        //扩充vswagger里面的配置
        config['baseType'] = _.assign({
            'Timestamp': '',
            'string': '',
            'boolean': false,
            'integer': '',
            'object': {},
            'JSONObject': {},
            'number': '',
            'array': []
        }, config.baseType);
    
        if (projectName) {
            //遍历.vswagger.js中的projects
            config.projects = _.filter(config.projects, item => {
                if (projectName.split(',').indexOf(item.modelName) !== -1) {
                    return {
                        token: item.token || '',
                        modelName: item.modelName || '',
                        docUrl: item.docUrl || []
                    };
                }
            });
        }
    
        var template = config.template || 'vue-swagger-template';
        var hasSlash = template.indexOf('/') > -1;
    
        var tmp = path.join(home, '.vue-swagger', template.replace(/\//g, '-'));
    
        if (program.offline) {//vswagger init --offline
            logger.log('使用缓存模板 %s', chalk.yellow(tildify(tmp)));
            template = tmp;
        }
    
        // 判断template是否是本地的
        if (isLocalPath(template)) {
            var templatePath = getTemplatePath(template, projectPath);
            //判断templatePath是否存在，存在的话执行generate方法
            if (fs.existsSync(templatePath)) {
                generate(projectPath, templatePath, config, generateDone);
            } else {
                logger.fatal('找不到本地模板 "%s".', template);
            }
        } else {
            checkVersion(() => {
                if (!hasSlash) {
                    // 使用离线模版
                    var officialTemplate = 'Git-leng/' + template;
                    downloadAndGenerate(officialTemplate, tmp, projectPath, config);
                } else {
                    downloadAndGenerate(template, tmp, projectPath, config);
                }
            });
        }
    }
    
    function downloadAndGenerate (template, tmp, projectPath, config) {
        var spinner = ora('正在下载模板.');
        spinner.start();
        // 删除本地已有的api文件
        if (fs.existsSync(tmp)) rimraf.sync(tmp);
        download(template, tmp, {
            clone: program.clone || false
        }, function (err) {
            spinner.stop();
            if (err) logger.fatal('模板下载失败 ' + template + ': ' + err.message.trim());
            generate(projectPath, tmp, config, generateDone);
        });
    }
    
    function generateDone (error, files) {
        if (error) logger.fatal(error);
        _.forEach(files, (file) => {
            logger.success(chalk.green('%s'), '更新成功   ', `${path.relative(projectPath, tildify(file))}`);
        });
    }

```

### 一、发布npm包

这一步我们要弄清楚如何发布npm包，

#### 1、先执行npm adduser 输入账号 密码和邮箱（注意此步骤一定要验证邮箱）

这是我运行之后报的错：

```javascript
    npm ERR! code E401
    npm ERR! Registry returned 401 for PUT on http://registry.npm.xxs.com/-/user/org.couchdb.user:ty0225: unauthorized
    
    npm ERR! A complete log of this run can be found in:
    npm ERR!     /Users/tahara/.npm/_logs/2019-07-01T10_17_22_157Z-debug.log
```

是因为之前设置了某个源 现在要把源设置为npm官方的源

```javascript
npm config get registry 查看源
npm config set registry https://registry.npmjs.org 修改源
```

然后执行npm publish

成功后在别的项目中执行npm install npmname 即可使用

更新npm包也适用npm publish 不过要注意修改package.json的版本号，不然会报错


参考文献：

[使用commander.js做一个Nodejs命令行程序](http://blog.gejiawen.com/2016/09/21/make-a-node-cli-program-by-commander-js/)

[npm publish 发布](https://www.cnblogs.com/pingfan1990/p/4824658.html)