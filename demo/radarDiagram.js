/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/chart/radar-active/index.js":
/*!*****************************************!*\
  !*** ./src/chart/radar-active/index.js ***!
  \*****************************************/
/***/ (() => {

eval("let start = 0;\nlet vert = `\nattribute vec4 a_Position ; \nattribute vec3  a_Color ; \nvarying vec3 v_Color ;\nuniform vec4 offset ;\nvarying vec4 a_offset ;\n\nvoid main(){\na_offset = offset ;\ngl_Position = a_Position ;\ngl_PointSize = 2.0;\n}`,\n  frag = `#ifdef GL_ES\nprecision mediump float;\n// 把 r限制在 R+- 00.1的范围内 然后，取反\n#define SMOOTH(r,R) (1.0-smoothstep(R-.001,R+.001, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-.001,a+.001,x)*(1.0-smoothstep(b-.001,b+.001,x)) )// 结果就是x >a && x<b 后面用一减取反了\n\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n#endif\n\n#define  pi 3.14159265359 \n\nuniform float u_Time ;\nuniform vec2 u_CanvasSize ;\nvarying vec3 v_Color ;\n\n//  这个函数好像内置了？我enter一下怎么就出来了\nmat2 rotate(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\nmat2 scale(vec2 scale){\n    return mat2(scale.x, 0.0, 0.0, scale.y);\n}\nfloat crossAngle(float x , float y , float radius){ \n    float r = sqrt(x*x + y*y) ;// 点乘再开平方会比直接length或者distance要好吗\n    \n    return r<radius && (abs(x-y)<0.001 || abs(x+y)<0.001 )? 1.0:0.0;\n}\n\nfloat line(vec2 st, float k, float b,float w){ \n    return smoothstep(w,0., abs(st.y -st.x * k -b) );\n}\n// 改直线为射线 这次的思路是先画一条九点钟方向的射线 然后偏移 这里的偏移仅仅是旋转\n// 先把当前坐标 逆偏移到 三点钟方向\nfloat ray(vec2 st, float angle ,float r, float w){\n    st *= rotate(-angle) ; \n    return length(st)<r && st.x>0.? smoothstep(w, 0., abs(st.y )):.0;\n}\nfloat circle (float r, vec2 st, float w) { \n    // return  step(-w,-abs(length(st)-r) ) ; 画圆还是得用平滑\n    // return smoothstep(w,0.0, abs(length(st) - r)) ;//还是不够平滑\n    return smoothstep(w,0.0, abs(sqrt(dot(st,st) )- r)) ;// 不够\n}\n//看来用两个stepsmooth 相减的效果要优于直接用绝对值\nfloat circle2(vec2 uv,  float radius, float width)\n{\nfloat r = length(uv );\nreturn SMOOTH(r-width,radius)-SMOOTH(r+width,radius);\n}\n\n// 没看懂他那个逻辑 ，我直接用角度判断吧 用正弦的范围 刚好符合这个轴对称 【-0.1，0.1】的都不画\nfloat circle4(vec2 uv,  float radius, float width, float min,float max)\n{\nfloat r = length(uv );    \n    // sinval = y/r 对边比斜边 \n    float sinval = uv.y / r ;\nreturn  sinval > min && sinval < max ? SMOOTH(r-width,radius)-SMOOTH(r+width,radius):0.0;\n}\n// 虽然用1减上面的结果就可以取反，到那时上面用了绝对值，这次要不用绝对值的\nfloat circle3(vec2 uv,  float radius, float width, float sinval)\n{\nfloat r = length(uv );    \n    // sinval = y/r 对边比斜边    \nreturn  abs(uv.y/r) < sinval ? 0.0:SMOOTH(r-width,radius)-SMOOTH(r+width,radius);\n}\n\n// 看上去这个函数很麻烦，看不懂，先直接用 radius应该是三角形的位置 \nfloat triangles(vec2 uv, float radius)\n{\nvec2 d = uv;\n//加法代表或，乘法代表且 原来如此，每条边都过它的对点做一条平行线， 限制在这两平行线之间，三个条件交叉的部分就只有三角形了，\n// 分析第一个三角  -0.009 < x- radius < 0  ===> x在【r-0.009， r】内，     x - radius \nreturn RS(-.009, 0.0, d.x-radius) * (1.0-smoothstep( 0.007+d.x-radius,0.009+d.x-radius, abs(d.y)))\n        + RS( 0.0, 0.009, d.x+radius) * (1.0-smoothstep( 0.007-d.x-radius,0.009-d.x-radius, abs(d.y)))\n        + RS(-.009, 0.0, d.y-radius) * (1.0-smoothstep( 0.007+d.y-radius,0.009+d.y-radius, abs(d.x)))\n        + RS( 0.0, 0.009, d.y+radius) * (1.0-smoothstep( 0.007-d.y-radius,0.009-d.y-radius, abs(d.x)));\n}\n\nfloat triangle(vec2 st, float r ){\n    float  x= st.x,y = st.y;// 0.7近似根号2的一半\n    return step(-r, y) *step( y - x, -r*0.7 ) *step( y + x, -r*0.7 )\n    +      step( y,r) *step( r*0.7,y - x  ) *step( r*0.7, y + x )\n    +      step( x,r) *step( y-x, -r*0.7  ) *step( r*0.7, x+y )\n    +      step(-r, x) *step( r*.7 ,y - x) *step( y + x, -r*0.7 )\n    ;\n\n    \n}\n        \n    \n// 因为我默认就是圆点圆心，所以pos就是偏移。\nfloat circleMove(vec2 st, vec2 pos, float radius, float w ){\n    // 简单一点，直接逆变换然后调用之前得函数\n    st-=pos ;\n    return circle(radius, st,w) ;\n}\n// 圆环加径向渐变 加移动\nfloat circleWave(vec2 st ,vec2 pos ,float radius, float width){ \n    // 还需要判断是否超出了扫描范围，超出了不予渲染\n    if(length(st) >0.35)return 0.;\n    st -=pos ;\n    float d  = length(st) ; \n    float percent = (radius - d) /width ;// 反了？确实反了 难怪效果有点奇怪，按我现在的写法，w实际上是双倍的\n    // float percent = 1.- (radius - d) /width/2.0 ;//上面得会有负数，所以才觉得怪怪得，扫描是加法，所以效果是那样得 \n    // float percent =  1.-( 1.+ (radius - d) /width)/2. ;//先把值域搞到0-1 然后取反\n    \n    return (SMOOTH(d-width,radius)-SMOOTH(d+width,radius))*percent;\n//  return  circle2(vec2 uv,  float radius, float width)\n}\n\nfloat circledot(vec2 st , vec2 pos , float r ){\n    st -=pos ;\n    float  d= length(st) ;\n    return smoothstep(0.0, 0.01, r -d) ; // 要求是 d < r\n}\n\n// 扇形 而且随着角度加大变淡 结合射线与圆弧 再加上旋转变换，不过这里可以不用矩阵，因为已经把角度求出来了，只需要\n// 按我现在的代码就是默认从 12点钟方向开始 逆时针逐渐加强\nfloat sector(vec2 st , float r ,float endAng, float offset ){ \n    float d = length(st) ;\n    // 余弦值的值域比较好控制 就用它,还是直接用反三角函数算了\n    float cosVal = st.y/ d ; // 把这个d变成r ，结果就是扇形减去三角形剩余圆弧\n    float ang = acos(cosVal) ;\n    // 同样 这个偏移要逆着用\n    ang-=offset ;\n    // 我逻辑是比较角度大小 所以小于零要处理   有while 但是我写了错了\n    ang = mod(ang,2.*pi);\n    if(ang <0.)ang+=2.*pi;\n    if(st.x<0.) ang = 2.0 * pi - ang ;\n    // 渐变 就是百分比  \n    float percent  = ang / endAng ;\n    return d < r && ang < endAng ? percent:0. ;\n}\n\nfloat sector2(vec2 st , float r ,float endAng, float offset ){ \n    float d = length(st) ;\n    // 余弦值的值域比较好控制 就用它,还是直接用反三角函数算了\n    float cosVal = st.y/ d ; // 把这个d变成r ，结果就是扇形减去三角形剩余圆弧\n    float ang = acos(cosVal) ;\n    if(st.x<0.) ang = 2.0 * pi - ang ;\n    // 同样 这个偏移要逆着用\n    ang-=offset ;\n    // 我逻辑是比较角度大小 所以小于零要处理   有while 但是我写了错了\n    ang = mod(ang,2.*pi);\n    if(ang <0.)ang+=2.*pi;\n    // 渐变 就是百分比  \n    float percent  = ang / endAng ;\n    return d < r && ang < endAng ? percent:0. ;\n}\n\n// shader不好调试，但是js可以啊\n\n\nmat3 yuv2rgb = mat3(1.0, 0.0, 1.13983,\n                1.0, -0.39465, -0.58060,\n                1.0, 2.03211, 0.0);\n\n// RGB to YUV matrix\nmat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722,\n                -0.09991, -0.33609, 0.43600,\n                0.615, -0.5586, -0.05639);\n\nuniform sampler2D NAME;\nvoid main(){\n        vec4 colorT = texture2D(NAME, vec2(.5));\n        float t = u_Time/1000. ;\n        float ratio  = u_CanvasSize.x/u_CanvasSize.y;\n        vec2 st  =gl_FragCoord.xy / u_CanvasSize ;\n        // 还是先把坐标处理到中心方便点\n        st-= vec2(.5)  ;\n        st.x*=ratio ;\n        vec3 color  =vec3(0.0) ;\n        // 我的三角形 \n        color = mix(color, vec3(.7,.1,.9), triangle(st,0.1));\n\n        vec2 translate  = vec2( sin(t), cos(t))*0.3 ; \n        // st +=translate ;\n        // 先位移再旋转 就是在位移的同时旋转，先旋转再位移，就定在一个地方旋转了，好奇怪\n        \n        float gap = .03;\n        // st-=0.5 ;\n        // st *=2.0 ;\n        // color = yuv2rgb* vec3(0.5, st) ;\n        vec3 color1= vec3(1) ;\n        vec3 color2= vec3(0.3) ;\n        color = mix(color,  color2,crossAngle(st.x,st.y,0.35)) ;\n        // color = mix( color, color1,  line( st,-1.0, 0.0) + line( st,1.0, 0.0)) ;\n        // color = mix( color, blue1, circle(0.25, st,0.001)) ;\n        // 漏了一个小圆\n        color = mix( color, blue1, circle2( st,0.03, 0.0011)) ;\n        color = mix( color, blue1, circle2( st,0.15, 0.001)) ;\n        color = mix( color, blue1, circle2( st,0.25, 0.001)) ;\n        color += vec3(circle2( st,0.35, 0.002)) ;\n        // 画第四层圆弧 \n        color = mix( color, blue3, circle3( st,0.38, 0.001, 0.5 + 0.2*sin(t))) ;\n        // 五层要分4次画\n        color = mix( color, blue1, circle4( st,0.45, 0.003, sin(gap), sin(pi/4. -gap))) ;\n        color = mix( color, blue1, circle4( st,0.45, 0.003,  -sin(pi/4.-gap), -sin(gap))) ;\n            //  想要角度上的均匀就得用角度。\n\n        color =  mix( color, blue3 -0.1, circle4( st,0.45, 0.003, sin(pi/4. +gap), sin(pi/2. -gap))) ;\n        color =  mix( color, blue3 -0.1, circle4( st,0.45, 0.003,  - sin(pi/2. -gap),-sin(pi/4. +gap))) ;\n\n        // 画三角形\n        color+=triangles(st,0.45 + 0.05*sin(t))* vec3(0.79, 0.19, 0.19) ;      \n\n        \n        // 发现目标 \n        vec2 pos = vec2(.15*(sin(t/30.)+cos(t/50.)), .18*cos(t/20.+1.)) ;\n        // 还是 要一个小圆环 里面一个圆点 圆点还有用得  但是要能漂移，所以得重写一个\n        color = mix(color, red, circleMove(st,pos,.01,0.002)) ;\n        color = mix(color, red, circledot(st,pos,.01)) ;\n        // 加上扩散动画 不能用三角函数了 要用取余，或着 超出为0 ，从原本的效果上看是直接取余的\n        float r1=  .1*mod(t,1.) ;\n\n        // 我想扫到才有动画，这样就需要判断当前 目标的位置是否在扇形区域内，当然实际雷达并不是这样扫描的\n        // clamp (t,min ,max)限制值在min  max之间，超出则取对应的边界值 我要限制\n        color = mix(color, red, circleWave(st,pos,r1, 0.02)) ;\n\n        // 画小白点 \n        vec2 pos1 =vec2(.4*sin(-t/10.)+ .1* cos(-t/10.0+1.), .15*cos(-t/4.) + .17*sin(t/50.+1.));\n        vec2 pos2 =vec2(.2*sin(t/30.-1.)+ .1*cos(t/20.0)+.1*sin(t/5.) , .16*cos(-t/10.)- .09*cos(-t/40.+1.) - .18*sin(-t/50.));\n        color = mix(color, color1, circledot(st,pos1,.01)) ;\n        color = mix(color, color1, circledot(st,pos2,.01)) ;\n    \n\n        // 扫描 放在最上层吧\n            // color = mix( color , blue2, line(st, tan(t), 0., 0.01)) ;\n        color = mix( color , blue3, ray(st,-t , 0.35, 0.005)) ;\n\n        // 扇形  和射线初始偏差是 90  ，然后用90 - 扇形的弧度   扫描的位置等于初始 12点 + 扇形弧度 + 旋转量\n        color = mix(color, blue3, sector2(st,0.35, pi/2.5, t+pi/2. - pi/2.5 )) ;\n            gl_FragColor = vec4(color,1)+ colorT ;\n}\n`;\n\n// main('./shader.vert', './shapingFunction.frag') ;\nmain(vert, frag);\nfunction handleContextmenu(e) {\n  console.log(e);\n}\nfunction initShaders(gl, vertexShader, fragmentShader) {\n  const program = gl.createProgram();\n  const veshader = loadShader(gl, gl.VERTEX_SHADER, vertexShader);\n  const fragShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShader);\n  gl.attachShader(program, veshader);\n  gl.attachShader(program, fragShader);\n  gl.linkProgram(program);\n  gl.useProgram(program);\n  gl.program = program;\n}\nfunction loadShader(gl, type, code) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, code);\n  gl.compileShader(shader);\n  return shader;\n}\nasync function main(vert, frag) {\n  // fetch(url).then(res => {  res.text()}).then((text))\n\n  let canvas = document.getElementById('d3');\n  let wh = [window.innerWidth - 10, window.innerHeight - 30];\n  canvas.width = wh[0];\n  canvas.height = wh[1];\n  canvas.addEventListener('contextmenu', handleContextmenu);\n  let gl = canvas.getContext('webgl');\n  initShaders(gl, vert, frag);\n  let a_Uv = gl.getAttribLocation(gl.program, 'a_Uv');\n  let a_Position = gl.getAttribLocation(gl.program, 'a_Position');\n  let u_Time = gl.getUniformLocation(gl.program, 'u_Time');\n  let u_CanvasSize = gl.getUniformLocation(gl.program, 'u_CanvasSize');\n  gl.uniform2fv(u_CanvasSize, wh);\n\n  // gl.enable(gl.ALPHA)\n  const vertexes = new Float32Array(8 * 2);\n  const elementBytes = vertexes.BYTES_PER_ELEMENT;\n  console.log(elementBytes);\n  // 数据集变了 ，这个索引也得变\n  const indices = new Uint8Array([0, 2, 4, 6]);\n  vertexes.set([-1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, -1, 1, 0], 0);\n\n  // const uv = new Float32Array([\n  //     0,1,\n  //     1,1,\n  //     0,0,\n  //     1,0\n  // ])\n\n  let buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, vertexes, gl.STATIC_DRAW);\n  // index, size, type, normalized, stride, offset\n  gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * elementBytes, 0);\n  gl.enableVertexAttribArray(a_Position);\n  a_Uv > 0 && gl.vertexAttribPointer(a_Uv, 2, gl.FLOAT, 0, 2 * 4, 2 * 4);\n\n  // 索引\n  let indBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n  window.addEventListener('resize', handleResize);\n  console.log(gl);\n  ani();\n  gl.clearColor(0, 0, 0, 1);\n  function draw() {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.drawElements(gl.TRIANGLE_STRIP, indices.length, gl.UNSIGNED_BYTE, 0);\n    // gl.drawElements(gl.POINTS,1, gl.UNSIGNED_BYTE, 0)\n  }\n\n  function handleContext() {\n    let pixels = new Float32Array(4);\n    gl.readPixels(0, 0, wh[0], wh[1], gl.RGBA, gl.FLOAT, pixels);\n  }\n  function handleResize(e) {\n    wh[0] = canvas.clientWidth;\n    wh[1] = canvas.clientHeight;\n    // 不使用投影矩阵，我的单位就是裁剪空间的，也就是百分比，自然也就不用更新这个了\n    // gl.viewport(0,    0, wh[0], wh[1])\n    // 原来是忘了更新画布尺寸了， 画布尺寸和viewport似乎有差别\n    canvas.width = wh[0];\n    canvas.height = wh[1];\n    console.log(...wh);\n    //    这个似乎没有更新成功\n    gl.uniform2fv(u_CanvasSize, wh);\n  }\n  function updateShaderdata(t) {\n    gl.uniform1f(u_Time, t);\n  }\n  function ani(t = 0) {\n    if (t - start > 1000 / 12) {\n      start = t;\n      updateShaderdata(t);\n      draw();\n    }\n    requestAnimationFrame(ani);\n  }\n}\nlet ps = Promise.resolve(1);\nfunction handdleChnage(file) {\n  ps = new Promise((res, rej) => {});\n}\n\n//# sourceURL=webpack://three/./src/chart/radar-active/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/chart/radar-active/index.js"]();
/******/ 	
/******/ })()
;